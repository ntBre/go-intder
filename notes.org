Delay using this for now, I may end up doing something different with
the input file anyway

#+begin_src go
  // integer absolute value
  func iabs(i int) int {
	  if i < 0 {
		  return -i
	  }
	  return i
  }

  // value of a with the sign of b
  func isign(a, b int) int {
	  if b < 0 {
		  return -a
	  }
	  return a
  }

  // update config based on other values, from intder.f
  if conf[NVEC] != 0 {
	  conf[NEQ] = 1
  }
  if iabs(conf[NTEST]) == 3 {
	  conf[NSTOP] = 1
	  conf[NINV] = isign(1, conf[NTEST])
  }
  if iabs(conf[NINV]) == 3 {
	  conf[NEQ] = 0
	  conf[NVEC] = 0
	  // GOTO 117 ?? skips ahead a bit but not sure what to
	  // do here TODO
  }

#+end_src

potential help in psi3/src/bin/intder


* how to do internal coordinate displacements
  1. [X] compute reference SIC value
  2. [X] apply displacement to SIC
  3. [ ] convert from displaced SIC to cartesians
     - this is the hard part
     - the other option is to conver the displacement to cartesians
       first and apply that to the cartesian geometry
  #+begin_src python :results output
    import matplotlib.pyplot as plt
    import numpy as np

    H1 = np.array([0.0000000000,  1.4313902070,  0.9860411840])
    H2 = np.array([0.0000000000, -1.4313902070,  0.9860411840])
    O = np.array([0.0000000000,   0.0000000000, -0.1242384530])
    colors = np.array([[255, 0, 0], [255, 0, 0], [0, 0, 255]])

    H1new = np.array([0.0000000000,  1.4183902070,  0.9820411840])
    H2new = np.array([0.0000000000, -1.4283902070,  0.9890411840])

    xs = list(map(lambda x: x[0], [H1, H2, O]))
    ys = list(map(lambda x: x[1], [H1, H2, O]))
    zs = list(map(lambda x: x[2], [H1, H2, O]))

    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    ax.scatter(xs, ys, zs, c=colors/255, marker='o', s=100)

    ax.quiver(0, 0, 0, *H1, color="red")
    ax.quiver(0, 0, 0, *H2, color="blue")
    ax.quiver(0, 0, 0, *H1/2, color="green")
    ax.quiver(0, 0, 0, *H2/2, color="green")
    plt.show()
  #+end_src

  #+RESULTS:

  - for each disp
    - a stretch is a vector from atom 1 to 2, just lengthen that
      vector by moving the second atom away. but what if that breaks a
      different bond? that's the hard part
    - this example makes it look easy

      might have to dive in and see exactly how they construct the B
      matrix

      this is B matrix after calling MACHB

  (0,                     0,                   -0)
  (0.7901604711325243,    0,                    0.63936038937065331)
  (0.61290001620136003,   0,                   -0.82427360602746957)
  (-0,                    0,                    0)
  (-0.7901604711325243,   0.7901604711325243,   0)
  (-0.61290001620136003, -0.61290001620136003,  1.6485472120549391)
  (0,                    -0,                   -0)
  (0,                    -0.7901604711325243,  -0.63936038937065331)
  (0,                     0.61290001620136003, -0.82427360602746957)

  first col, rows 1-3 are a unit vector from atom1 to atom2; first col
  rows 4-6 are a unit vector from atom2 to atom1

  ohhh it must be 2-1, 2-3, 2-2 or something, the last one is all
  zeroes because it's to itself; 1-2, 1-3, 1-1 maybe, but why that
  order?

  the second column is similar, but the third column is quite
  different

  values of k1,k2 in second call to vect1 are 2 and 3, consistent with
  previous observation

  the first column looks like 0-1, 1-0, 0-0
  second column is 1-1, 1-2, 2-1

  the third column doesnt look like unit vectors, well the first and
  last entries do but not the middle group of 3

* MACHB
  - main -> intder -> disp -> machb
